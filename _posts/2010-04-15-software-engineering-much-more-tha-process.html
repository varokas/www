---
layout: post
title: Software Engineering >> Processes
date: 2010-04-15 22:36:42.000000000 +07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Software Engineering
tags: []
meta:
  _edit_last: '12346080'
  _wpas_done_fb: '1'
  _wpas_done_twitter: '1'
author:
  login: varokas
  email: varokas@panusuwan.com
  display_name: varokas
  first_name: ''
  last_name: ''
---
<p>One of the misconception that I overheard so many times is that software engineering is all about "boring process stuff only managers care about". As I explore deeper into SE, I see much much more than just management (process) aspect of it. In general, I could cite a few definitions of SE from textbooks, but here's my own version of it:</p>
<blockquote><p>All those stuff that gears us towards writing software that delivers on time with at least defects as possible</p></blockquote>
<p>A few of the "stuff" I am talking about are:</p>
<ul>
<li>Software Development Management and Processes - Know how close you are to completion. Increase predictability of project time. Examples:
<ul>
<li>Planning, Tracking and Oversight - Know where you are in the project</li>
<li>Risk Management - Know your odds of success</li>
</ul>
</li>
<li>Requirements Engineering and Modelling: Understands what your customer needs ( More often enable them to understand what they need!), decrease functional defects. Examples:
<ul>
<li>Formal Modelling - Mathematically infers properties for your software (We guarantee this to be deadlock free!)</li>
<li>Prototypes - A mock up replica of finished system</li>
</ul>
</li>
<li>Architectural Design - Satisfies the quality attributes of the system to build ( decrease defects, big ones )</li>
<li>Quality Assurance - The most misunderstood about in the group. A lot of fun stuff emerges from this. Examples:
<ul>
<li>Languages Constructs - Surprising to some, but data types was born to prevent you from mixing your variables, is it not?</li>
<li>Static Analysis - Using a program to verify correctness of other programs. Very hot research topic</li>
<li>Peer Review/Pair Programming - Friends helps friends eliminate silly mistakes</li>
<li>Automated Testing</li>
<li>Continuous Integration - Guaranteed that all the builds works</li>
</ul>
</li>
</ul>
<p>It is sad oftentimes people think Software Engineering is reserved only for those who just finished their Bachelor in CS, and does not know coding enough to dig deeper. Truth is that folks who study SE handle themselves pretty well in, and love, coding. I believe that you need to code for a while before you can appreciate all good practices SE has to offer. SE won't help you find new algorithms, but helps you decides which one to choose based on what is needed ( is Big O always the most important thing?). SE won't help you learn new languages, but let you decides which one makes more sense to use ( Does readability always the most important thing?). I do believe that the worst code in the world is the perfect code for the wrong thing. Because you already wasted time, with no return. And I strongly believe all achievements in SE would prevent (or trying very hard to prevent) you from doing so.</p>
<p>Bottom line: I think SE is all about being effective. Folks who love constant personal/team improvements would definitely love SE. We will do whatever it takes to make great software -- one that actually ships on time. Be it the process, be  it the tools, be it the organization culture to change, be it the new languages. We constantly pursue the art of making the right software, and making development fun in the process.</p>
